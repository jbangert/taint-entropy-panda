// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trace.proto

#ifndef PROTOBUF_trace_2eproto__INCLUDED
#define PROTOBUF_trace_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tentropy {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_trace_2eproto();
void protobuf_AssignDesc_trace_2eproto();
void protobuf_ShutdownFile_trace_2eproto();

class BlockExecution;
class BlockExecution_MemAccess;
class CodeBlock;
class Trace;

// ===================================================================

class BlockExecution_MemAccess : public ::google::protobuf::Message {
 public:
  BlockExecution_MemAccess();
  virtual ~BlockExecution_MemAccess();

  BlockExecution_MemAccess(const BlockExecution_MemAccess& from);

  inline BlockExecution_MemAccess& operator=(const BlockExecution_MemAccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockExecution_MemAccess& default_instance();

  void Swap(BlockExecution_MemAccess* other);

  // implements Message ----------------------------------------------

  BlockExecution_MemAccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockExecution_MemAccess& from);
  void MergeFrom(const BlockExecution_MemAccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 addr = 1;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 1;
  inline ::google::protobuf::uint64 addr() const;
  inline void set_addr(::google::protobuf::uint64 value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:tentropy.BlockExecution.MemAccess)
 private:
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 addr_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static BlockExecution_MemAccess* default_instance_;
};
// -------------------------------------------------------------------

class BlockExecution : public ::google::protobuf::Message {
 public:
  BlockExecution();
  virtual ~BlockExecution();

  BlockExecution(const BlockExecution& from);

  inline BlockExecution& operator=(const BlockExecution& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockExecution& default_instance();

  void Swap(BlockExecution* other);

  // implements Message ----------------------------------------------

  BlockExecution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockExecution& from);
  void MergeFrom(const BlockExecution& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BlockExecution_MemAccess MemAccess;

  // accessors -------------------------------------------------------

  // required uint64 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint64 start() const;
  inline void set_start(::google::protobuf::uint64 value);

  // required uint64 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);

  // repeated .tentropy.BlockExecution.MemAccess write = 3;
  inline int write_size() const;
  inline void clear_write();
  static const int kWriteFieldNumber = 3;
  inline const ::tentropy::BlockExecution_MemAccess& write(int index) const;
  inline ::tentropy::BlockExecution_MemAccess* mutable_write(int index);
  inline ::tentropy::BlockExecution_MemAccess* add_write();
  inline const ::google::protobuf::RepeatedPtrField< ::tentropy::BlockExecution_MemAccess >&
      write() const;
  inline ::google::protobuf::RepeatedPtrField< ::tentropy::BlockExecution_MemAccess >*
      mutable_write();

  // repeated .tentropy.BlockExecution.MemAccess read = 4;
  inline int read_size() const;
  inline void clear_read();
  static const int kReadFieldNumber = 4;
  inline const ::tentropy::BlockExecution_MemAccess& read(int index) const;
  inline ::tentropy::BlockExecution_MemAccess* mutable_read(int index);
  inline ::tentropy::BlockExecution_MemAccess* add_read();
  inline const ::google::protobuf::RepeatedPtrField< ::tentropy::BlockExecution_MemAccess >&
      read() const;
  inline ::google::protobuf::RepeatedPtrField< ::tentropy::BlockExecution_MemAccess >*
      mutable_read();

  // repeated uint64 exec = 5;
  inline int exec_size() const;
  inline void clear_exec();
  static const int kExecFieldNumber = 5;
  inline ::google::protobuf::uint64 exec(int index) const;
  inline void set_exec(int index, ::google::protobuf::uint64 value);
  inline void add_exec(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      exec() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_exec();

  // @@protoc_insertion_point(class_scope:tentropy.BlockExecution)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 start_;
  ::google::protobuf::uint64 end_;
  ::google::protobuf::RepeatedPtrField< ::tentropy::BlockExecution_MemAccess > write_;
  ::google::protobuf::RepeatedPtrField< ::tentropy::BlockExecution_MemAccess > read_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > exec_;
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static BlockExecution* default_instance_;
};
// -------------------------------------------------------------------

class CodeBlock : public ::google::protobuf::Message {
 public:
  CodeBlock();
  virtual ~CodeBlock();

  CodeBlock(const CodeBlock& from);

  inline CodeBlock& operator=(const CodeBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CodeBlock& default_instance();

  void Swap(CodeBlock* other);

  // implements Message ----------------------------------------------

  CodeBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CodeBlock& from);
  void MergeFrom(const CodeBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline ::google::protobuf::uint64 identifier() const;
  inline void set_identifier(::google::protobuf::uint64 value);

  // required bytes code = 3;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 3;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const void* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // optional uint64 total_instr = 4;
  inline bool has_total_instr() const;
  inline void clear_total_instr();
  static const int kTotalInstrFieldNumber = 4;
  inline ::google::protobuf::uint64 total_instr() const;
  inline void set_total_instr(::google::protobuf::uint64 value);

  // optional uint64 bitwise_instr = 5;
  inline bool has_bitwise_instr() const;
  inline void clear_bitwise_instr();
  static const int kBitwiseInstrFieldNumber = 5;
  inline ::google::protobuf::uint64 bitwise_instr() const;
  inline void set_bitwise_instr(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tentropy.CodeBlock)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_total_instr();
  inline void clear_has_total_instr();
  inline void set_has_bitwise_instr();
  inline void clear_has_bitwise_instr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 identifier_;
  ::std::string* code_;
  ::google::protobuf::uint64 total_instr_;
  ::google::protobuf::uint64 bitwise_instr_;
  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static CodeBlock* default_instance_;
};
// -------------------------------------------------------------------

class Trace : public ::google::protobuf::Message {
 public:
  Trace();
  virtual ~Trace();

  Trace(const Trace& from);

  inline Trace& operator=(const Trace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trace& default_instance();

  enum ContentsCase {
    kCode = 1,
    kExectrace = 2,
    CONTENTS_NOT_SET = 0,
  };

  void Swap(Trace* other);

  // implements Message ----------------------------------------------

  Trace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trace& from);
  void MergeFrom(const Trace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tentropy.CodeBlock code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::tentropy::CodeBlock& code() const;
  inline ::tentropy::CodeBlock* mutable_code();
  inline ::tentropy::CodeBlock* release_code();
  inline void set_allocated_code(::tentropy::CodeBlock* code);

  // optional .tentropy.BlockExecution exectrace = 2;
  inline bool has_exectrace() const;
  inline void clear_exectrace();
  static const int kExectraceFieldNumber = 2;
  inline const ::tentropy::BlockExecution& exectrace() const;
  inline ::tentropy::BlockExecution* mutable_exectrace();
  inline ::tentropy::BlockExecution* release_exectrace();
  inline void set_allocated_exectrace(::tentropy::BlockExecution* exectrace);

  inline ContentsCase contents_case() const;
  // @@protoc_insertion_point(class_scope:tentropy.Trace)
 private:
  inline void set_has_code();
  inline void set_has_exectrace();

  inline bool has_contents();
  void clear_contents();
  inline void clear_has_contents();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union ContentsUnion {
    ::tentropy::CodeBlock* code_;
    ::tentropy::BlockExecution* exectrace_;
  } contents_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static Trace* default_instance_;
};
// ===================================================================


// ===================================================================

// BlockExecution_MemAccess

// required uint64 addr = 1;
inline bool BlockExecution_MemAccess::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockExecution_MemAccess::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockExecution_MemAccess::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockExecution_MemAccess::clear_addr() {
  addr_ = GOOGLE_ULONGLONG(0);
  clear_has_addr();
}
inline ::google::protobuf::uint64 BlockExecution_MemAccess::addr() const {
  // @@protoc_insertion_point(field_get:tentropy.BlockExecution.MemAccess.addr)
  return addr_;
}
inline void BlockExecution_MemAccess::set_addr(::google::protobuf::uint64 value) {
  set_has_addr();
  addr_ = value;
  // @@protoc_insertion_point(field_set:tentropy.BlockExecution.MemAccess.addr)
}

// required bytes data = 2;
inline bool BlockExecution_MemAccess::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockExecution_MemAccess::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockExecution_MemAccess::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockExecution_MemAccess::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& BlockExecution_MemAccess::data() const {
  // @@protoc_insertion_point(field_get:tentropy.BlockExecution.MemAccess.data)
  return *data_;
}
inline void BlockExecution_MemAccess::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:tentropy.BlockExecution.MemAccess.data)
}
inline void BlockExecution_MemAccess::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:tentropy.BlockExecution.MemAccess.data)
}
inline void BlockExecution_MemAccess::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tentropy.BlockExecution.MemAccess.data)
}
inline ::std::string* BlockExecution_MemAccess::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:tentropy.BlockExecution.MemAccess.data)
  return data_;
}
inline ::std::string* BlockExecution_MemAccess::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlockExecution_MemAccess::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:tentropy.BlockExecution.MemAccess.data)
}

// -------------------------------------------------------------------

// BlockExecution

// required uint64 start = 1;
inline bool BlockExecution::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockExecution::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockExecution::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockExecution::clear_start() {
  start_ = GOOGLE_ULONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::uint64 BlockExecution::start() const {
  // @@protoc_insertion_point(field_get:tentropy.BlockExecution.start)
  return start_;
}
inline void BlockExecution::set_start(::google::protobuf::uint64 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:tentropy.BlockExecution.start)
}

// required uint64 end = 2;
inline bool BlockExecution::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockExecution::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockExecution::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockExecution::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 BlockExecution::end() const {
  // @@protoc_insertion_point(field_get:tentropy.BlockExecution.end)
  return end_;
}
inline void BlockExecution::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:tentropy.BlockExecution.end)
}

// repeated .tentropy.BlockExecution.MemAccess write = 3;
inline int BlockExecution::write_size() const {
  return write_.size();
}
inline void BlockExecution::clear_write() {
  write_.Clear();
}
inline const ::tentropy::BlockExecution_MemAccess& BlockExecution::write(int index) const {
  // @@protoc_insertion_point(field_get:tentropy.BlockExecution.write)
  return write_.Get(index);
}
inline ::tentropy::BlockExecution_MemAccess* BlockExecution::mutable_write(int index) {
  // @@protoc_insertion_point(field_mutable:tentropy.BlockExecution.write)
  return write_.Mutable(index);
}
inline ::tentropy::BlockExecution_MemAccess* BlockExecution::add_write() {
  // @@protoc_insertion_point(field_add:tentropy.BlockExecution.write)
  return write_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tentropy::BlockExecution_MemAccess >&
BlockExecution::write() const {
  // @@protoc_insertion_point(field_list:tentropy.BlockExecution.write)
  return write_;
}
inline ::google::protobuf::RepeatedPtrField< ::tentropy::BlockExecution_MemAccess >*
BlockExecution::mutable_write() {
  // @@protoc_insertion_point(field_mutable_list:tentropy.BlockExecution.write)
  return &write_;
}

// repeated .tentropy.BlockExecution.MemAccess read = 4;
inline int BlockExecution::read_size() const {
  return read_.size();
}
inline void BlockExecution::clear_read() {
  read_.Clear();
}
inline const ::tentropy::BlockExecution_MemAccess& BlockExecution::read(int index) const {
  // @@protoc_insertion_point(field_get:tentropy.BlockExecution.read)
  return read_.Get(index);
}
inline ::tentropy::BlockExecution_MemAccess* BlockExecution::mutable_read(int index) {
  // @@protoc_insertion_point(field_mutable:tentropy.BlockExecution.read)
  return read_.Mutable(index);
}
inline ::tentropy::BlockExecution_MemAccess* BlockExecution::add_read() {
  // @@protoc_insertion_point(field_add:tentropy.BlockExecution.read)
  return read_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tentropy::BlockExecution_MemAccess >&
BlockExecution::read() const {
  // @@protoc_insertion_point(field_list:tentropy.BlockExecution.read)
  return read_;
}
inline ::google::protobuf::RepeatedPtrField< ::tentropy::BlockExecution_MemAccess >*
BlockExecution::mutable_read() {
  // @@protoc_insertion_point(field_mutable_list:tentropy.BlockExecution.read)
  return &read_;
}

// repeated uint64 exec = 5;
inline int BlockExecution::exec_size() const {
  return exec_.size();
}
inline void BlockExecution::clear_exec() {
  exec_.Clear();
}
inline ::google::protobuf::uint64 BlockExecution::exec(int index) const {
  // @@protoc_insertion_point(field_get:tentropy.BlockExecution.exec)
  return exec_.Get(index);
}
inline void BlockExecution::set_exec(int index, ::google::protobuf::uint64 value) {
  exec_.Set(index, value);
  // @@protoc_insertion_point(field_set:tentropy.BlockExecution.exec)
}
inline void BlockExecution::add_exec(::google::protobuf::uint64 value) {
  exec_.Add(value);
  // @@protoc_insertion_point(field_add:tentropy.BlockExecution.exec)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
BlockExecution::exec() const {
  // @@protoc_insertion_point(field_list:tentropy.BlockExecution.exec)
  return exec_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
BlockExecution::mutable_exec() {
  // @@protoc_insertion_point(field_mutable_list:tentropy.BlockExecution.exec)
  return &exec_;
}

// -------------------------------------------------------------------

// CodeBlock

// required uint64 identifier = 1;
inline bool CodeBlock::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CodeBlock::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CodeBlock::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CodeBlock::clear_identifier() {
  identifier_ = GOOGLE_ULONGLONG(0);
  clear_has_identifier();
}
inline ::google::protobuf::uint64 CodeBlock::identifier() const {
  // @@protoc_insertion_point(field_get:tentropy.CodeBlock.identifier)
  return identifier_;
}
inline void CodeBlock::set_identifier(::google::protobuf::uint64 value) {
  set_has_identifier();
  identifier_ = value;
  // @@protoc_insertion_point(field_set:tentropy.CodeBlock.identifier)
}

// required bytes code = 3;
inline bool CodeBlock::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CodeBlock::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CodeBlock::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CodeBlock::clear_code() {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& CodeBlock::code() const {
  // @@protoc_insertion_point(field_get:tentropy.CodeBlock.code)
  return *code_;
}
inline void CodeBlock::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set:tentropy.CodeBlock.code)
}
inline void CodeBlock::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set_char:tentropy.CodeBlock.code)
}
inline void CodeBlock::set_code(const void* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tentropy.CodeBlock.code)
}
inline ::std::string* CodeBlock::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:tentropy.CodeBlock.code)
  return code_;
}
inline ::std::string* CodeBlock::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CodeBlock::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:tentropy.CodeBlock.code)
}

// optional uint64 total_instr = 4;
inline bool CodeBlock::has_total_instr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CodeBlock::set_has_total_instr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CodeBlock::clear_has_total_instr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CodeBlock::clear_total_instr() {
  total_instr_ = GOOGLE_ULONGLONG(0);
  clear_has_total_instr();
}
inline ::google::protobuf::uint64 CodeBlock::total_instr() const {
  // @@protoc_insertion_point(field_get:tentropy.CodeBlock.total_instr)
  return total_instr_;
}
inline void CodeBlock::set_total_instr(::google::protobuf::uint64 value) {
  set_has_total_instr();
  total_instr_ = value;
  // @@protoc_insertion_point(field_set:tentropy.CodeBlock.total_instr)
}

// optional uint64 bitwise_instr = 5;
inline bool CodeBlock::has_bitwise_instr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CodeBlock::set_has_bitwise_instr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CodeBlock::clear_has_bitwise_instr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CodeBlock::clear_bitwise_instr() {
  bitwise_instr_ = GOOGLE_ULONGLONG(0);
  clear_has_bitwise_instr();
}
inline ::google::protobuf::uint64 CodeBlock::bitwise_instr() const {
  // @@protoc_insertion_point(field_get:tentropy.CodeBlock.bitwise_instr)
  return bitwise_instr_;
}
inline void CodeBlock::set_bitwise_instr(::google::protobuf::uint64 value) {
  set_has_bitwise_instr();
  bitwise_instr_ = value;
  // @@protoc_insertion_point(field_set:tentropy.CodeBlock.bitwise_instr)
}

// -------------------------------------------------------------------

// Trace

// optional .tentropy.CodeBlock code = 1;
inline bool Trace::has_code() const {
  return contents_case() == kCode;
}
inline void Trace::set_has_code() {
  _oneof_case_[0] = kCode;
}
inline void Trace::clear_code() {
  if (has_code()) {
    delete contents_.code_;
    clear_has_contents();
  }
}
inline const ::tentropy::CodeBlock& Trace::code() const {
  return has_code() ? *contents_.code_
                      : ::tentropy::CodeBlock::default_instance();
}
inline ::tentropy::CodeBlock* Trace::mutable_code() {
  if (!has_code()) {
    clear_contents();
    set_has_code();
    contents_.code_ = new ::tentropy::CodeBlock;
  }
  return contents_.code_;
}
inline ::tentropy::CodeBlock* Trace::release_code() {
  if (has_code()) {
    clear_has_contents();
    ::tentropy::CodeBlock* temp = contents_.code_;
    contents_.code_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Trace::set_allocated_code(::tentropy::CodeBlock* code) {
  clear_contents();
  if (code) {
    set_has_code();
    contents_.code_ = code;
  }
}

// optional .tentropy.BlockExecution exectrace = 2;
inline bool Trace::has_exectrace() const {
  return contents_case() == kExectrace;
}
inline void Trace::set_has_exectrace() {
  _oneof_case_[0] = kExectrace;
}
inline void Trace::clear_exectrace() {
  if (has_exectrace()) {
    delete contents_.exectrace_;
    clear_has_contents();
  }
}
inline const ::tentropy::BlockExecution& Trace::exectrace() const {
  return has_exectrace() ? *contents_.exectrace_
                      : ::tentropy::BlockExecution::default_instance();
}
inline ::tentropy::BlockExecution* Trace::mutable_exectrace() {
  if (!has_exectrace()) {
    clear_contents();
    set_has_exectrace();
    contents_.exectrace_ = new ::tentropy::BlockExecution;
  }
  return contents_.exectrace_;
}
inline ::tentropy::BlockExecution* Trace::release_exectrace() {
  if (has_exectrace()) {
    clear_has_contents();
    ::tentropy::BlockExecution* temp = contents_.exectrace_;
    contents_.exectrace_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Trace::set_allocated_exectrace(::tentropy::BlockExecution* exectrace) {
  clear_contents();
  if (exectrace) {
    set_has_exectrace();
    contents_.exectrace_ = exectrace;
  }
}

inline bool Trace::has_contents() {
  return contents_case() != CONTENTS_NOT_SET;
}
inline void Trace::clear_has_contents() {
  _oneof_case_[0] = CONTENTS_NOT_SET;
}
inline Trace::ContentsCase Trace::contents_case() const {
  return Trace::ContentsCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace tentropy

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trace_2eproto__INCLUDED
